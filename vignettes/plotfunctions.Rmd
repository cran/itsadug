---
title: "Visualization of nonlinear interactions"
author: "Jacolien van Rij"
date: "version `r format.Date(Sys.Date(), '%B %d, %Y')`"
bibliography: bibliography.bib
output:   
  rmarkdown::html_document:
    fig_caption: yes
    toc: true
    theme: readable
    highlight: default
vignette: >
  %\VignetteIndexEntry{Visualization of nonlinear interactions in itsadug}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---
<style>
td      {padding:5pt;}
p       {margin-top: 2em;}
</style>

# Introduction
The package **`itsadug`** (http://github.com/vr-vr/itsadug) includes several plot functions to visualize the estimates of Generalized Additive (Mixed) Models (GAMM) implemented using the package **`mgcv`** [@Wood_2006; -@Wood_2011].
This paper presents a short overview of:

- the available plot functions in the packages `mgcv` and `itsadug`;

- the functions to retrieve predicted values from a GAMM, and how these could be used to create custom plots;

- the plot functions for inspection of the residuals. 

## Example GAMM model
The code below was used to fit a GAMM model `m1` to the data set `simdat` from the package `itsadug`. The data set `simdat` is simulated time series data with arbitrary predictors. We use the interaction between the predictors *Time* and *Trial* to illustrate the various functions that are available for visualizing nonlinear interactions.

```{r, results='hide'}
library(itsadug)

data(simdat)

# For illustration purposes, we build a GAMM model
# with a nonlinear interaction, two groups, and
# random wiggly smooths for Subjects:
m1 <- bam(Y ~ Group + te(Time, Trial, by=Group)
  + s(Time, Subject, bs='fs', m=1),
  data=simdat)
```

The function **`gamtabs`** converts the summary quickly in a Latex table or in a HTML table (specify `type="html"`), which could be included in a `knitr` file.


```{r, eval=TRUE, results='asis'}
gamtabs(m1, caption="Summaty of m1", comment=FALSE, type='html')
```


# Nonlinear interactions
## 1. plot.gam() for partial effects

The default way to plot interactions is to use `mgcv`'s **`plot.gam`**. This function visualizes the partial effects, see Figure 1.

```{r,plotgam, echo=TRUE, include=TRUE, fig.width=8, fig.height=4, fig.cap="<b>Figure 1.</b> Partial effects surfaces <code>te(Time,Trial):GroupChildren</code> and <code>te(Time,Trial):GroupAdults</code> plotted with <code>plot.gam</code>."}
par(mfrow=c(1,2))
plot(m1, select=1, rug=FALSE,
     main='Group=Children', cex.axis=1.5, cex.lab=1.5)
plot(m1, select=2, rug=FALSE,
     main='Group=Adults', cex.axis=1.5, cex.lab=1.5)
```

Advantage and disadvantages of **`plot.gam`**:

- Confidence bands are plotted, which are useful for seeing whether effects are significant.

- Without colored background the contour plots are difficult to read. It is possible to plot a colored background using the argument `scheme=2`, but only `heat.colors` are possible. 

- The use of `plot.gam` is limited to interactions with two (or less) continuous variables.


## 2. pvisgam() for partial effects

Alternatively one could use the function **`pvisgam`** from the package `itsadug` to visualize the partial effects. The function plots exactly the same surfaces as `plot.gam`, but visualizes the surface slightly different. 

```{r, fig.width=8, fig.height=4, echo=TRUE, include=TRUE,fig.cap="<b>Figure 2.</b> Partial effects surfaces <code>te(Time,Trial):GroupChildren</code> and <code>te(Time,Trial):GroupAdults</code> plotted with <code>pvisgam</code>."}
par(mfrow=c(1,2))
# Note: specify zlim when comparing two plots
pvisgam(m1, view=c("Time", "Trial"), select=1, 
     main='Group=Children', labcex=.8,
     zlim=c(-15,15), print.summary=FALSE)
pvisgam(m1, view=c("Time", "Trial"), select=2, 
     main='Group=Adults', labcex=.8,
     zlim=c(-15,15), print.summary=FALSE)
```

Advantage and disadvantages of **`pvisgam`**:

- `pvisgam` plots are easier to interpret than `plot.gam` plots, because the background is colored.

- This function can be used to plot more complex interactions, including more than two continuous predictors.

- The surfaces might look different when being plot with different z-range (`zlim`), which changes the colors and contour lines being plot. 

- Highly similar in appearance to the function `vis.gam` (summarized in next section). Therefore, it is good practice to report which function and settings were used to generate the plot.


## 3. vis.gam() for summed effects
For visualizing the summed effects, rather than partial effects, `mgcv`'s function **`vis.gam`** could be used. The functions `pvisgam` and `fvisgam` are derived from **`vis.gam`**, and therefore look very similar in style. 


```{r, visgam, fig.width=8, fig.height=4, echo=TRUE, include=TRUE,fig.cap="<b>Figure 3.</b> Summed effects surfaces for <i>Time</i> and <i>Trial</i> plotted with <code>vis.gam</code>."}
par(mfrow=c(1,2))
# Note: specify zlim when comparing two plots
vis.gam(m1, view=c("Time", "Trial"), 
        cond=list(Group='Children', Subject='a01'),
        plot.type='contour', color='topo', main='Group=Children',
        zlim=c(-8,10))
vis.gam(m1, view=c("Time", "Trial"), 
        cond=list(Group='Adults', Subject='a01'),
        plot.type='contour', color='topo', main='Group=Adults',
        zlim=c(-8,10))
```

Advantages and disadvantages of **`vis.gam`**:

- It shows the additive effect of the different nonlinear components, which facilitates interpretation; 

- This function can be used to plot more complex interactions, including more than two continuous predictors;

- The surfaces might look different when being plot with different z-range (`zlim`), which changes the colors and contour lines being plot; 

- **`vis.gam`** requires a value for each predictor in the model, and also includes the random effects (e.g., effects for participants and items). This makes it difficult to generalize over the random effects. 

Different settings for not viewed predictors may change the surface. Therefore, it is good practice to report which settings were used to generate the plot.


The function **`gradientLegend`** in the package `itsadug` can be used to add a color legend to the **`vis.gam`** plot (automatically added by `pvisgam` and `fvisgam`).


## 4. fvisgam() for summed effects
The function **`fvisgam`** in `itsadug` is a variant of `vis.gam` that allows to exclude random effects. Figure 4 shows similar patterns as the partial effects in Figures 1 and 2, but the values on the contour lines are different. This is caused by the intercept and other terms in the model that are added as constants to the surface. When the random effects would *not* be excluded (i.e., setting `rm.ranef` to `NULL`) the surfaces in Figure 4 would be the same as with `vis.gam` (Figure 3).

```{r, fvisgam,fig.width=8, fig.height=4, echo=FALSE, include=TRUE,fig.cap="<b>Figure 4.</b> Summed effects surfaces for <code>Time</code> and <code>Trial</code> plotted with <code>fvisgam</code>. Random effects are zeroed out."}
par(mfrow=c(1,2))
# Note: specify zlim when comparing two plots
fvisgam(m1, view=c("Time", "Trial"), 
        cond=list(Group='Children'),
        plot.type='contour', color='topo', main='Group=Children',
        zlim=c(-12,15), print.summary=FALSE)
fvisgam(m1, view=c("Time", "Trial"), 
        cond=list(Group='Adults'),
        plot.type='contour', color='topo', main='Group=Adults',
        zlim=c(-12,15))
```


Unless the argument \code{print.summary} is set to \code{FALSE}, the function will print the values of all model terms that are being used to generate the predictions.

Advantages and disadvantages of **`fvisgam`**:

- It shows the additive effect of the different nonlinear components, which facilitates interpretation; 

- This function can be used to plot more complex interactions, including more than two continuous predictors;

- The surfaces might look different when being plot with different z-range (`zlim`), which changes the colors and contour lines being plot; 

- It allows to generalize over random effects.

- It reports the values of the other model terms that are not in view, but might influence the plot.

Different settings for not viewed predictors may change the surface. Therefore, it is good practice to report which settings were used to generate the plot.


# Other plots
## 1. plot.gam() for partial effects
The default function for plotting a one dimensional smooth is **`plot.gam`**. This function plots the partial effect of a particular one dimensional smooth in the model. The argument `shift` could be used to raise or lower the smooth with the intercept or intercept adjustments, as shown in Figure 5.

```{r, plotSmooth1-code, echo=TRUE, include=FALSE, eval=FALSE}
par(mfrow=c(1,2), cex=1.1)
# As there is no one-dimensional smooth in model m1,
# the interaction of m1 is decomposed in smooths and 
# partial interactions:
m2 <- bam(Y ~ Group + s(Time, by=Group)
  + s(Trial, by=Group) + ti(Time, Trial, by=Group)
  + s(Time, Subject, bs='fs', m=1), data=simdat)

# To plot the smooth over time for Children:
plot(m2, select=1, shade=TRUE, rug=FALSE, scale=0)
title(main="s(Time):GroupChildren")
abline(h=0) # add horizontal line

# Now we add the intercept term:
plot(m2, select=1, shade=TRUE, rug=FALSE, scale=0,
  shift=coef(m2)[1])
title(main="s(Time):GroupChildren")
mtext('incl. intercept', side=3, line=.5, cex=1.1)
abline(h=0) # add horizontal line
```
```{r,plotSmooth1, echo=FALSE, fig.width=8, fig.height=4, include=TRUE, fig.cap="<b>Figure 5.</b> Using <code>plot.gam</code> for plotting a one dimensional smooth."}
par(mfrow=c(1,2), cex=1.1)
# As there is no one-dimensional smooth in model m1,
# the interaction of m1 is decomposed in smooths and 
# partial interactions:
m2 <- bam(Y ~ Group + s(Time, by=Group)
  + s(Trial, by=Group) + ti(Time, Trial, by=Group)
  + s(Time, Subject, bs='fs', m=1), data=simdat)

# To plot the smooth over time for Children:
plot(m2, select=1, shade=TRUE, rug=FALSE, scale=0)
title(main="s(Time):GroupChildren")
abline(h=0) # add horizontal line

# Now we add the intercept term:
plot(m2, select=1, shade=TRUE, rug=FALSE, scale=0,
  shift=coef(m2)[1])
title(main="s(Time):GroupChildren")
mtext('incl. intercept', side=3, line=.5, cex=1.1)
abline(h=0) # add horizontal line

# indicate effect of intercept:
abline(h=coef(m2)[1], lty=2, col='red')
arrows(x0=500,x1=500,y0=0,y1=coef(m2)[1], 
  code=2, length=.1, col='red', lwd=2)
text(500,coef(m2)[1], labels='+intercept', font=3, col='red', pos=3)
```

Advantages and disadvantages of **`plot.gam`**:

- Useful for inspection of the partial effects of nonlinear smooths.

- The use of `plot.gam` is limited to interactions with two (or less) continuous variables.


## 2. plot_smooth() for summed effects
The function **`plot_smooth`** from the package `itsadug` does not plot the partial effects, but the summed effects. Thus, when plotting the smooth for one particular group, the intercept for that group is also included in the smooth. Optionally the random effects could be excluded by setting the argument `rm.ranef` to `FALSE`.

```{r,plotSmooth2, echo=TRUE, fig.width=8, fig.height=4, fig.show='hold', include=TRUE, fig.cap="<b>Figure 6.</b> <i>Left:</i> Using plot_smooth for plotting a one dimensional smooth from model <code>m2</code>. <i>Right:</i> Using plot_smooth for extracting a one dimensional smooth from an interaction surface in model <code>m1</code>."}
par(mfrow=c(1,2), cex=1.1)

# First plot the smooth for Adult participants in gray...
plot_smooth(m2, view="Time", cond=list(Group="Adults"), rug=FALSE, 
  ylim=c(-10,15), print.summary=FALSE,
  main='m2: Time, Group=Adults')
# ... then add the smooth from which the random effects are excluded
plot_smooth(m2, view="Time", cond=list(Group="Adults"), 
  rug=FALSE, add=TRUE, col='red', rm.ranef=TRUE, 
  ylim=c(-10,15), print.summary=FALSE, xpd=TRUE)
# Add legend:
legend('bottomleft', 
  legend=c("incl. random","excl. random"),
  col=c("black", "red"), lwd=2,
  bty='n')

# Secondly, a smooth based on the tensor in m1:
plot_smooth(m1, view="Time", cond=list(Group="Adults"), 
  rug=FALSE, ylim=c(-10,15), print.summary=FALSE,
  main='m1: Time, Group=Adults')
plot_smooth(m1, view="Time", cond=list(Group="Adults"), 
  rug=FALSE, add=TRUE, col='red', rm.ranef=TRUE, 
  ylim=c(-10,15), print.summary=FALSE, xpd=TRUE)
```

Figure 6 *Left* and *Right* shows the same plot, *Left* is based on model `m2`, whereas *Right* is based on model `m1`. Remember that model `m1` included only interaction surfaces, but no one dimensional smooths. The function **`plot_smooth`** can derive the estimates of a one dimensional smooth on the basis of the complex interactions. Although very similar, deriving the estimate from an interaction surface results in a different smooth, because it is based on a different model.

Advantages and disadvantages of **`plot_smooth`**:

- Useful for inspection of the summed effects of nonlinear smooths;

- Allows to overlay the smooths of different conditions;

- The function **`plot_smooth`** is able to plot interactions with two (or less) continuous variables.


## 3. plot_parametric() for plotting group averages
The function **`plot_parametric`** plots the estimates for one or more grouping predictors as a dotplot, see Figure 7.

```{r, plotDots, echo=TRUE, fig.width=4, fig.height=4,include=TRUE, fig.cap="<b>Figure 7.</b> Estimates for each group when all other predictors are set to zero."}
par(cex=1.1)

# First plot the Group estimates by setting the smooth terms on zero:
plot_parametric(m1, pred=list(Group=c("Adults", "Children")),  
  cond=list(Time=0, Trial=0), rm.ranef=TRUE, 
  print.summary=FALSE)
```


## 4. plot_diff() and plot_diff2() for differences
The differences in the *Time* by *Trial* interaction between the adult participants and the children could be modeled using a binary predictor resulting in a difference surface. Alternatively, one could use the function **`plot_diff2`** of package `itsadug` to calculate and plot the difference surface. The function **`plot_diff`** is the one dimensional version of **`plot_diff2`**. 

```{r,plotdiff, echo=TRUE, fig.width=8, fig.height=4, include=TRUE, fig.cap="<b>Figure 8.</b> Difference surface for <code>Group</code> plotted with <code>plot_diff2</code>.",fig.show='hold'}
par(mfrow=c(1,2))
plot_diff2(m1, view=c("Time","Trial"), 
        comp=list(Group=c("Adults", "Children")),
        zlim=c(-5,7.5), 
        main='Difference Adults-Children',
        print.summary=FALSE)
plot_diff(m1, view="Time",         
        comp=list(Group=c("Adults", "Children")),
        main='Time difference Adults-Children')
```

Note that the random effects do not need to removed, because these are canceled out when the difference between the conditions is calculated.


# Using predictions to customize plots

Rather than using the functions `plot.gam`, `pvisgam`, `vis.gam`, `fvisgam`, or `plot_smooth` the model predictions provide a way to make your own plots. The functions **`get_predictions`**, **`get_random`**, and **`get_difference`** return predictions for given conditions. Using the same GAMM model, we provide an example of how to make a contour plot and smooths on the basis of predictions.

## 1. image(), contour() for visualizing surfaces

For a contour plot, one need to generate all combinations of x- and y-values. These can be specified in the argument `cond` of the function **`get_predictions`** of `itsadug`.
A matrix is created out of these values, and consequently plotted using the functions image and contour, as shown in Figure 9.

```{r, predict1, echo=TRUE, include=TRUE}
# Extract prediction from model
# Note that the random effects are canceled out by setting rm.ranef to TRUE
xval <- seq(0,2000, length=100)
yval <- seq(-10,10, length=50)
g1 <- get_predictions(m1, cond=list(Time=xval, Trial=yval, Group='Adults'), 
                      rm.ranef=TRUE, print.summary=FALSE)
# Create plot matrix
g1 <- g1[order(g1$Time, g1$Trial),]
zval <- matrix(g1$fit, byrow=TRUE, nrow=100,ncol=50)
```

```{r, image1, echo=TRUE, include=TRUE,fig.width=4, fig.height=4,fig.cap="<b>Figure 9.</b> Using <code>image()</code> and <code>contour()</code> to plot the interaction surface."}
image(xval, yval, zval, col=topo.colors(100),
      main='Group=Adults', xlab='Time', ylab='Trial')
contour(xval, yval, zval, labcex=.8, add=TRUE, col='red')
```

## 2. get_predictions() for visualizing smooths
To explain how the reader should interpret this surface, one could use two smooths that illustrate how Time influences the dependent variable at Trial 5 and Trial -5. I generated two data frames, one for `Trial==5` and one for `Trial==-5`:

```{r, predict2, echo=TRUE, include=TRUE}
# Extract prediction from model
# Note that the random effects are canceled out by setting rm.ranef to TRUE
xval <- seq(0,2000, length=100)
g2 <- get_predictions(m1, cond=list(Time=xval, Trial=5, Group='Adults'), 
                      rm.ranef=TRUE, print.summary=FALSE)
g3 <- get_predictions(m1, cond=list(Time=xval, Trial=-5, Group='Adults'), 
                      rm.ranef=TRUE, print.summary=FALSE)
head(g2)
```

In the leftmost of the following plots, the interaction surface is plotted again. Now two arrows are added to indicate which smooths are being plot in the rightmost panel:

```{r, image2, echo=TRUE, fig.width=8, fig.height=4, include=TRUE,fig.cap="<b>Figure 10.</b> <i>Left:</i> Interaction between Time and Trial for adult participants. <i>Right:</i> The effect of Time for Trial 5 (A) and Trial -5 (B) with 95% CI."}
par(mfrow=c(1,2))

image(xval, yval, zval, col=topo.colors(100),
      main='Group=Adults', xlab='Time', ylab='Trial')
contour(xval, yval, zval, labcex=.8, add=TRUE, col='red')
# Add arrows for comparing two conditions
arrows(x0=0, x1=2200, y0=5, y1=5, code=2, 
  length=.1, angle=30, lwd=2, xpd=TRUE)
arrows(x0=0, x1=2200, y0=-5, y1=-5, code=2, 
  length=.1, angle=30, lwd=2, col='magenta', xpd=TRUE)
text(2100, c(5,-5), labels=c('A', 'B'), 
  col=c('black', 'magenta'), pos=3, cex=1.1, xpd=TRUE)

# Setup the plot region for the two smooths:
emptyPlot(range(g2$Time), 
  range(c(g2$fit+g2$CI, g2$fit-g2$CI,g3$fit+g3$CI, g3$fit-g3$CI)),
  main='Trials 5 and -5', xlab='Time', ylab='Est. value of Y',
  h0=0)

# add two smooths:
# Note: f is set to 1, because the SE are already multiplied by 1.96 to get 95%CI
plot_error(g2$Time, g2$fit, g2$CI, 
  shade=TRUE, f=1, xpd=TRUE)
plot_error(g3$Time, g3$fit, g3$CI, 
  col='magenta', shade=TRUE, f=1, xpd=TRUE)

# add text as legend:
text(1500,c(15,10), labels=c("A", "B"), 
  col=c('black', 'magenta'), font=2, adj=0)

```

## 3. get_random() to visualize random effects

It might be useful to inspect the random effects estimates. The random smooths do not necessarily sum to zero, and might show drifts. By default, random effects are plotted by the function `plot.gam`. To calculate the mean or median of the random effects, the function `get_random` may be helpful.

```{r,predictRandom, echo=TRUE, include=TRUE}
# Extract the mean of the random smooths from model m1
g4 <- get_random(m1, fun='mean')
# Extract the median of the random smooths from model m1
g5 <- get_random(m1, fun='median')
```

```{r, random, echo=TRUE, fig.width=8, fig.height=4, include=TRUE, fig.cap="<b>Figure 11.</b> <i>Left:</i> Random effects smooths. <i>Right:</i> The mean (black) and median (blue) of the random smooths."}
par(mfrow=c(1,2))

plot(m1, select=3, ylim=c(-20,20))
title(main="Random smooths")
abline(h=0)

# Plot the mean random smooth:
itsadug::emptyPlot(range(g4[[1]]$Time), c(-10,10),
    main='Mean and median of random smooths', 
    xlab='Time', ylab='Est. value of Y',
    h0=0)
lines(g4[[1]]$Time, g4[[1]]$x, lwd=2, xpd=TRUE)
lines(g5[[1]]$Time, g5[[1]]$x, lwd=2, col='blue', xpd=TRUE)
```

# Inspection of residuals
## 1. check_resid() and resid_gam()
The function **`check_resid`** can be used to inspect the residual error of the model. It checks for the distribution of the model and the the autocorrelation in the residuals. For GAMM models without AR1 model, only the standard residuals are presented. However, it will reflect both the standard and the corrected residuals in models with an AR1 model included, because the function makes use of **`resid_gam`**. **`resid_gam`** can be used to retrieve the corrected residuals rather than the normal residuals.

```{r, resid, echo=TRUE, fig.width=8, fig.height=8, include=TRUE, warning=FALSE, fig.cap="<b>Figure 12.</b> <i>Top row:</i> Test the distribution of the model residuals for normality. The residuals seem to follow a t-distribution rather than normal distribution. <i>Bottom row:</i> The autocorrelation in the residuals. The left panel shows the acf of all the residuals, treating them as a single time series. The right panel is based on the function <code>acf_plot</code>, which averages over the time series."}
# Note: as no AR1 model was included, resid() is used instead of resid_gam()

check_resid(m1, split_by=list(Subject=simdat$Subject, Trial=simdat$Trial))
```

## 2. acf_plot() and acf_n_plots()
To test the structure of the autocorrelation, the function **` acf_n_plots`** presents $N$ acf plots of individual participants or time series. These time series can be randomly selected, or provide an overview of the differences by selecting time series on the basis of the quantiles, as illustrated in Figure 13.

```{r, acfplots, echo=TRUE, fig.width=12, fig.height=8, include=TRUE, fig.cap="<i>Figure 13.</i> 6 ACF plots, averaged over time series."}
acf_n_plots(resid(m1), 
  split_by=list(Subject=simdat$Subject, Trial=simdat$Trial), 
  n=6,cex.lab=1.5, cex.axis=1.5, cex.main=2)
```

## 3. acf_resid()
The function **`acf_resid()`** is a shortcut for plotting the ACF of model residuals. This function is also available for other regression models and `lmer()` / `glmer()` models. Note that the `split_pred` argument can take a vector with names of model terms that define how to split the data. If the argument `n` is being used, `acf_n_plots` is being called, otherwise `acf_plot`.

```{r, acfresid, echo=TRUE, fig.width=4, fig.height=4, include=TRUE, fig.cap="<i>Figure 14.</i> ACF plot of model residuals."}
acf_resid(m1, split_pred=c("Subject", "Trial"))
```


# Package info
This summary was created on \today.
```{r,packageVersions, echo=TRUE, include=TRUE}
packageVersion("mgcv")
packageVersion("itsadug")
```

Use the following command for the citation information in BibTex format: 
```{r} 
citation("itsadug")
```


# References
[id]:http://github.com/vr-vr/itsadug

